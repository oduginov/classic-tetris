/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { showIntroWindow } = __webpack_require__(/*! ./modules/modal-window */ \"./src/modules/modal-window.js\");\nconst { run } = __webpack_require__(/*! ./modules/game */ \"./src/modules/game.js\");\n\nshowIntroWindow(run);\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/modules/canvas.js":
/*!*******************************!*\
  !*** ./src/modules/canvas.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  SIZE_FIELD,\n  LINE_PIXELS_IN_SQUARE,\n  GAME_BOARD_COLOR\n} = __webpack_require__(/*! ./constants */ \"./src/modules/constants.js\");\n\n/* Declare and initialize variables for work with the canvas */\n\nconst canvas = document.getElementById('canvas');\nconst cols = SIZE_FIELD.WIDTH * LINE_PIXELS_IN_SQUARE;\nconst rows = SIZE_FIELD.HEIGHT * LINE_PIXELS_IN_SQUARE;\ncanvas.width = cols;\ncanvas.height = rows;\n\nconst context = canvas.getContext('2d');\n\ncanvas.style.backgroundColor = GAME_BOARD_COLOR;\n\n/**\n * Paint a pixel of the canvas with given coordinates (x, y) in the\n * specified color.\n *\n * @param x - The first canvas coordinate of a pixel\n * @param y - The second canvas coordinate of a pixel\n * @param color - The color of a pixel\n */\nfunction drawPixel(x, y, color) {\n  context.fillStyle = color;\n  context.fillRect(x, y, 1, 1);\n}\n\nfunction paintRect(x1, y1, x2, y2, color) {\n  context.fillStyle = color;\n  context.fillRect(x1, y1, Math.abs(x2 - x1 + 1), Math.abs(y2 - y1 + 1));\n}\n\nfunction getColorOfPixel(x, y) {\n  const center = {\n    x: x + Math.floor(LINE_PIXELS_IN_SQUARE / 2),\n    y: y + Math.floor(LINE_PIXELS_IN_SQUARE / 2)\n  };\n  return rgbaToHex(\n    Array.from(context.getImageData(center.x, center.y, 1, 1).data)\n  );\n}\n\n/**\n * Given a specific color in the rgba format [r, g, b, a], we obtain\n * the hex code of the color.\n *\n * @param {Number} r - Red component of the color.\n * @param {Number} g - Green component of the color.\n * @param {Number} b - Blue component of the color.\n * @param {Number} a - Opacity.\n * @returns {string} HexCode of the given color\n */\nfunction rgbaToHex([r, g, b]) {\n  return `#${[r.toString(16), g.toString(16), b.toString(16)]\n    .map(c => (c === '0' ? '00' : c))\n    .join('')}`;\n}\n\n/**\n * Clear the canvas.\n */\nfunction clearCanvas() {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nmodule.exports = { drawPixel, paintRect, getColorOfPixel, clearCanvas };\n\n\n//# sourceURL=webpack:///./src/modules/canvas.js?");

/***/ }),

/***/ "./src/modules/constants.js":
/*!**********************************!*\
  !*** ./src/modules/constants.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Enumerate all tetriminoes and assign the number for each tile\n *\n * @type {{S: number, T: number, I: number, J: number, Z: number,\n * L: number, O: number}}\n */\nconst TETROMINOS = { I: 0, O: 1, T: 2, L: 3, J: 4, Z: 5, S: 6 };\n\n/**\n * Define increments of the score. According to the rule\n * the classic tetris, we increment the score by 40 * (level+1),\n * 100 * (level + 1), 300 * (level + 1) points, if the number of\n * the destroyed horizontal lines is exactly 1,2 and 3, respectively,\n * and by 1200 * (level + 1) points, if we have the tetris, i.e. the\n * number of the destroyed lines equals to 4.\n *\n */\nconst SCORE_INCREMENTS = [40, 100, 300, 1200];\n\nconst LEVEL_THRESHOLDS = [\n  10,\n  20,\n  30,\n  40,\n  50,\n  60,\n  70,\n  80,\n  90,\n  100,\n  100,\n  100,\n  100,\n  100,\n  100,\n  100,\n  110,\n  120,\n  130,\n  140,\n  150,\n  160,\n  170,\n  180,\n  190,\n  200,\n  200,\n  200,\n  200\n];\n\n/**\n * Define size of the game field\n * @type {{WIDTH: number, HEIGHT: number}} - Width and height of the game zone\n */\nconst SIZE_FIELD = {\n  WIDTH: 10,\n  HEIGHT: 20\n};\n\nconst LINE_PIXELS_IN_SQUARE = 24;\n\nconst GAME_BOARD_COLOR = '#000';\n\nconst RED = {\n  innerColor: '#ff2000',\n  borderColors: ['#1c0000', '#490703', '#4c0600', '#9e372d', '#b7301e']\n};\nconst BLUE = {\n  innerColor: '#ffffff',\n  borderColors: ['#150034', '#34007e', '#5900cb', '#7e00f6', '#ac6dff']\n};\nconst PURPLE = {\n  innerColor: '#6d00ff',\n  borderColors: ['#10002a', '#26005d', '#270061', '#4800ae', '#5e00de']\n};\n\nmodule.exports = {\n  TETROMINOS,\n  SCORE_INCREMENTS,\n  SIZE_FIELD,\n  LINE_PIXELS_IN_SQUARE,\n  GAME_BOARD_COLOR,\n  RED,\n  BLUE,\n  PURPLE,\n  LEVEL_THRESHOLDS\n};\n\n\n//# sourceURL=webpack:///./src/modules/constants.js?");

/***/ }),

/***/ "./src/modules/game-board.js":
/*!***********************************!*\
  !*** ./src/modules/game-board.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { paintSquare, eraseSquare } = __webpack_require__(/*! ./square */ \"./src/modules/square.js\");\nconst { SIZE_FIELD } = __webpack_require__(/*! ./constants */ \"./src/modules/constants.js\");\nconst { clearCanvas } = __webpack_require__(/*! ./canvas */ \"./src/modules/canvas.js\");\n\n// Bitmap of the game board\nconst bitmap = new Array(SIZE_FIELD.HEIGHT).fill(false);\n\n// Initialize of the bitmap\nbitmap.forEach((item, index, baseArray) => {\n  baseArray[index] = new Array(SIZE_FIELD.WIDTH);\n  baseArray[index].fill(false);\n});\n\n/**\n * Check whether square (x, y) is free?\n *\n * @param {number} x - The first coordinate of the square on the game board.\n * @param {number} y - The second coordinate of the square on the game board.\n * @returns {boolean} - True, if the square is free, and false, otherwise.\n */\nfunction isSquareFree(x, y) {\n  return !bitmap[y][x];\n}\n\n/**\n * Draw squares of a tetromino on the game board.\n *\n * @param squares - The array of the tetromino's squares.\n * @param innerColor - The color of inner area of the square.\n * @param borderColors - The array of the colors for the square border.\n */\nfunction drawTetromino(squares, innerColor, borderColors) {\n  squares.forEach(s => paintSquare(s.x, s.y, innerColor, borderColors));\n}\n\n/**\n * Put a square on the game board.\n *\n * @param x - The first coordinate on the game board.\n * @param y - The second coordinate on the game board.\n * @param innerColor - The color of inner area of the square.\n * @param borderColors - The array of the colors for the square border.\n */\nfunction putSquare(x, y, innerColor, borderColors) {\n  paintSquare(x, y, innerColor, borderColors);\n  takeSquare(x, y);\n}\n\n/**\n * Erase of the tetromino squares on the game board.\n *\n * @param tetromino - Tetromino object (see, please, <./tetromino.js>)\n */\nfunction eraseTetromino(tetromino) {\n  tetromino.forEach(s => eraseSquare(s.x, s.y));\n}\n\n/**\n * Delete a square from the game board and bitmap.\n *\n * @param x - The first coordinate of the deleted square on the game board.\n * @param y - The second coordinate of the deleted square on the game board.\n */\nfunction deleteSquare(x, y) {\n  eraseSquare(x, y);\n  bitmap[y][x] = false;\n}\n\n/**\n * Fix a square on the game board.\n *\n * @param x - The first coordinate of the deleted square on the game board.\n * @param y - The second coordinate of the deleted square on the game board.\n */\nfunction takeSquare(x, y) {\n  bitmap[y][x] = true;\n}\n\n/**\n * Get an array of row indices (on the game board) filled by tetrominos.\n *\n * @returns {[]} - The array of indices.\n */\nfunction getFullLines() {\n  const fullLines = [];\n  bitmap.forEach((row, index) => {\n    if (row.every(element => element)) {\n      fullLines.push(index);\n    }\n  });\n  return fullLines;\n}\n\n/**\n * Check whether the row with the index <row> is filled by tetrominos.\n *\n * @param row - The index of the line on the game board.\n * @returns {boolean}\n */\nfunction isEmptyLine(row) {\n  return bitmap[row].every(s => !s);\n}\n\n/**\n * Check whether the last by one row has a square of a tetromino. If it is, then\n * we finish current game.\n *\n * @returns {boolean}\n */\nfunction isFullGameBoard() {\n  return bitmap[1].some(item => item);\n}\n\n/**\n * Clear the game board and bitmap.\n */\nfunction clearGameBoard() {\n  clearCanvas();\n  for (let i = 0; i < SIZE_FIELD.HEIGHT; i++) {\n    for (let j = 0; j < SIZE_FIELD.WIDTH; j++) {\n      bitmap[i][j] = false;\n    }\n  }\n}\n\nmodule.exports = {\n  drawTetromino,\n  eraseTetromino,\n  getFullLines,\n  deleteSquare,\n  putSquare,\n  isEmptyLine,\n  isSquareFree,\n  takeSquare,\n  isFullGameBoard,\n  clearGameBoard\n};\n\n\n//# sourceURL=webpack:///./src/modules/game-board.js?");

/***/ }),

/***/ "./src/modules/game.js":
/*!*****************************!*\
  !*** ./src/modules/game.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { SIZE_FIELD } = __webpack_require__(/*! ./constants */ \"./src/modules/constants.js\");\nconst gameBoard = __webpack_require__(/*! ./game-board */ \"./src/modules/game-board.js\");\nconst { tetrominos } = __webpack_require__(/*! ./tetromino */ \"./src/modules/tetromino.js\");\nconst { getColorOfSquare } = __webpack_require__(/*! ./square */ \"./src/modules/square.js\");\nconst { renderTetromino, clearCanvas } = __webpack_require__(/*! ./preview-canvas */ \"./src/modules/preview-canvas.js\");\nconst { showSettingsWindow, showEndGameWindow } = __webpack_require__(/*! ./modal-window */ \"./src/modules/modal-window.js\");\nconst {\n  show,\n  getScoreIncrement,\n  getLevelIncrement,\n  getDelayFrames\n} = __webpack_require__(/*! ./parameters */ \"./src/modules/parameters.js\");\n\n/*\n * Define variables\n */\nconst stopButton = document.getElementById('stop');\nconst startButton = document.getElementById('play');\nconst settings = document.getElementById('control');\nlet currentTetromino = null;\nlet nextTetromino = null;\nlet isPressedDownArrow = false;\nlet startLevel = 0;\nlet level = 0;\nlet score = 0;\nlet lines = 0;\nlet isStoppedGame = false;\nlet isFirstRunningGame = true;\nlet delayFrames = 0;\nlet prevDelayFrames = 0;\n\n/**\n * Generate a random tetromino.\n *\n * @returns {object} Object of the type <Tetromino>\n */\nfunction getTetromino() {\n  const i = Math.round(Math.random() * 6);\n  return tetrominos[i];\n}\n\nfunction updateParameters(levelIncr, delayFrameVar, lineIncr) {\n  level += levelIncr;\n  delayFrames = delayFrameVar;\n  lines += lineIncr;\n  show(score, lines, level);\n}\n\n/**\n * Run the game\n *\n * @param userLevel - The level at the beginning of the game.\n */\nfunction run(userLevel) {\n  isStoppedGame = false;\n  startLevel = userLevel;\n  level = startLevel;\n  if (isFirstRunningGame) {\n    init();\n    isFirstRunningGame = false;\n  }\n  currentTetromino = getTetromino();\n  currentTetromino.draw();\n  nextTetromino = getTetromino();\n  renderTetromino(nextTetromino);\n  updateParameters(0, getDelayFrames(level), 0);\n  let currentFrames = 0;\n\n  const repaint = () => {\n    if (currentFrames >= delayFrames) {\n      currentFrames = 0;\n      if (!move()) {\n        currentTetromino.saveState();\n        if (gameBoard.isFullGameBoard()) {\n          isStoppedGame = true;\n          clearCanvas();\n          gameBoard.clearGameBoard();\n          showEndGameWindow(score, run);\n          level = 0;\n          score = 0;\n          lines = 0;\n          return;\n        }\n        currentTetromino.reset();\n        const fullLines = gameBoard.getFullLines();\n        if (fullLines.length) {\n          burnLines(fullLines);\n          score += getScoreIncrement(fullLines.length, level);\n          const eps = getLevelIncrement(\n            startLevel,\n            level,\n            lines,\n            fullLines.length\n          );\n          updateParameters(eps, getDelayFrames(level), fullLines.length);\n        }\n        // Initiate dropping new tetromino\n        currentTetromino = nextTetromino;\n        currentTetromino.draw();\n        nextTetromino = getTetromino();\n        renderTetromino(nextTetromino);\n      }\n    }\n    currentFrames++;\n    requestAnimationFrame(repaint);\n  };\n  currentFrames++;\n  requestAnimationFrame(repaint);\n}\n\n/**\n * Animation of line burning.\n *\n * @param fullLines - The array of row indices filled by tetrominos.\n */\nfunction burnLines(fullLines) {\n  if (isPressedDownArrow) {\n    delayFrames = prevDelayFrames;\n    isPressedDownArrow = false;\n  }\n  let indexBurnedSquare = Math.floor(SIZE_FIELD.WIDTH / 2) - 1;\n  let currentFrames = 0;\n  const repaint = () => {\n    if (currentFrames >= 2) {\n      currentFrames = 0;\n      fullLines.forEach(line => {\n        gameBoard.deleteSquare(indexBurnedSquare, line);\n        gameBoard.deleteSquare(SIZE_FIELD.WIDTH - indexBurnedSquare - 1, line);\n      });\n      indexBurnedSquare--;\n    }\n    if (indexBurnedSquare >= 0) {\n      currentFrames++;\n      requestAnimationFrame(repaint);\n    } else {\n      dropLines(fullLines);\n    }\n  };\n  currentFrames++;\n  requestAnimationFrame(repaint);\n}\n\n/**\n * Animation of line dropping after burning of full lines.\n *\n * @param fullLines - The array of indices of rows that is filled by tetrominos.\n */\nfunction dropLines(fullLines) {\n  const repaint = () => {\n    let i = fullLines.shift();\n    while (i >= 1 && !gameBoard.isEmptyLine(i - 1)) {\n      for (let j = 0; j < SIZE_FIELD.WIDTH; j++) {\n        const color = getColorOfSquare(j, i - 1);\n        if (color) {\n          gameBoard.putSquare(j, i, color.innerColor, color.borderColors);\n          gameBoard.deleteSquare(j, i - 1);\n        }\n      }\n      i--;\n    }\n    if (fullLines.length) {\n      requestAnimationFrame(repaint);\n    }\n  };\n  requestAnimationFrame(repaint);\n}\n\n/**\n * Move the current tetromino by one line down.\n *\n * @returns {boolean} True, if we can move the current tetromino;\n * false, otherwise.\n */\nfunction move() {\n  const updatedSquares = currentTetromino.squares.map(square => ({\n    x: square.x,\n    y: square.y + 1\n  }));\n  return currentTetromino.move(updatedSquares);\n}\n\n/**\n * Add event listeners\n */\nfunction init() {\n  document.addEventListener('keydown', event => {\n    if (event.code === 'ArrowLeft' && !isStoppedGame) {\n      currentTetromino.moveLeft();\n    }\n    if (event.code === 'ArrowRight' && !isStoppedGame) {\n      currentTetromino.moveRight();\n    }\n    if (event.code === 'ArrowDown' && !isStoppedGame) {\n      if (!isPressedDownArrow) {\n        prevDelayFrames = delayFrames;\n        delayFrames = 3;\n        isPressedDownArrow = true;\n      }\n    }\n    if (event.code === 'KeyX' && currentTetromino.rotate && !isStoppedGame) {\n      currentTetromino.rotate(true);\n    }\n    if (event.code === 'KeyZ' && currentTetromino.rotate && !isStoppedGame) {\n      currentTetromino.rotate(false);\n    }\n    if (event.code === 'KeyS') {\n      stopStartGame();\n    }\n  });\n  document.addEventListener('keyup', event => {\n    if (event.code === 'ArrowDown' && isPressedDownArrow && !isStoppedGame) {\n      delayFrames = prevDelayFrames;\n      isPressedDownArrow = false;\n    }\n  });\n  document.addEventListener('click', stopStartGame);\n  settings.addEventListener('click', showMenu);\n}\n\nconst showMenu = () => {\n  if (!isStoppedGame) {\n    stopStartGame();\n  }\n  showSettingsWindow();\n};\n\nconst stopStartGame = event => {\n  if (!event || event.target.classList.contains('control')) {\n    if (delayFrames === Infinity) {\n      delayFrames = prevDelayFrames;\n      isStoppedGame = false;\n      stopButton.style.display = 'inline-block';\n      startButton.style.display = 'none';\n    } else {\n      prevDelayFrames = delayFrames;\n      delayFrames = Infinity;\n      isStoppedGame = true;\n      startButton.style.display = 'inline-block';\n      stopButton.style.display = 'none';\n    }\n  }\n};\n\nmodule.exports = { run };\n\n\n//# sourceURL=webpack:///./src/modules/game.js?");

/***/ }),

/***/ "./src/modules/modal-window.js":
/*!*************************************!*\
  !*** ./src/modules/modal-window.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const topic = document.getElementById('topic');\nconst content = document.getElementById('content');\nconst modalWindow = document.querySelector('.modal-window');\n\nconst keyboardShortcuts = [\n  { key: 's', action: 'pause/unpause' },\n  { key: 'z', action: 'left rotation of a tile' },\n  { key: 'x', action: 'right rotation of a tile' },\n  { key: 'left arrow', action: 'left shift of a tile' },\n  { key: 'right arrow', action: 'right shift of a tile' },\n  { key: 'down arrow', action: 'speed-up' }\n];\n\nfunction showEndGameWindow(score, run) {\n  content.innerHTML = '';\n  topic.textContent = 'Tetris Game';\n  let span = document.createElement('span');\n  span.textContent = 'Score: ';\n  content.appendChild(span);\n  span = document.createElement('span');\n  span.textContent = score;\n  span.style.color = 'white';\n  content.appendChild(span);\n  modalWindow.style.visibility = 'visible';\n  const button = document.createElement('button');\n  button.textContent = 'New game';\n  button.addEventListener('click', () => {\n    showIntroWindow(run);\n  });\n  content.appendChild(button);\n}\n\nfunction showIntroWindow(run) {\n  content.innerHTML = '';\n\n  const fragment = document.createDocumentFragment();\n  const button = document.createElement('button');\n  topic.textContent = 'Tetris Game';\n  const label = document.createElement('label');\n  label.textContent = 'Select the level of the game (from 0 to 29): ';\n  label.setAttribute('for', 'level');\n  fragment.appendChild(label);\n  const input = document.createElement('input');\n  input.setAttribute('type', 'number');\n  input.setAttribute('id', 'level');\n  input.setAttribute('min', '0');\n  input.setAttribute('max', '29');\n  fragment.appendChild(input);\n  button.textContent = 'Start';\n  button.addEventListener('click', () => {\n    const level = Number(input.value);\n    if (!isNaN(level) && level >= 0 && level <= 29) {\n      run(level);\n      document.querySelector('.modal-window').style.visibility = 'hidden';\n    }\n  });\n  fragment.appendChild(button);\n  content.appendChild(fragment);\n\n  modalWindow.style.visibility = 'visible';\n}\n\nfunction showSettingsWindow() {\n  content.innerHTML = '';\n\n  const fragment = document.createDocumentFragment();\n  const button = document.createElement('button');\n  topic.textContent = 'Keyboard Shortcuts';\n  const ul = document.createElement('ul');\n  keyboardShortcuts.forEach(item => {\n    const li = document.createElement('li');\n    li.textContent = `${item.key}: ${item.action}`;\n    ul.appendChild(li);\n  });\n  fragment.appendChild(ul);\n  button.textContent = 'Close';\n  button.addEventListener('click', () => {\n    document.querySelector('.modal-window').style.visibility = 'hidden';\n  });\n  fragment.appendChild(button);\n  content.appendChild(fragment);\n  modalWindow.style.visibility = 'visible';\n}\n\nmodule.exports = { showIntroWindow, showSettingsWindow, showEndGameWindow };\n\n\n//# sourceURL=webpack:///./src/modules/modal-window.js?");

/***/ }),

/***/ "./src/modules/parameters.js":
/*!***********************************!*\
  !*** ./src/modules/parameters.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { SCORE_INCREMENTS } = __webpack_require__(/*! ./constants */ \"./src/modules/constants.js\");\n\n/**\n * Render the score, the total number of the burned lines and the level\n * of the game on the html page.\n *\n * @param score - The current score in the game.\n * @param lines - The current burned lines in the game.\n * @param level - The current level in the game.\n */\nfunction show(score, lines, level) {\n  document.getElementById('score').textContent = score;\n  document.getElementById('lines').textContent = lines;\n  document.getElementById('level').textContent = level;\n}\n\n/**\n * Calculate the increment of the score. It depends on the current level\n * and the current number of burned lines.\n *\n * @param numberOfBurnedLines - The current number of burned lines at the moment.\n * @param level - The current level in the game.\n * @returns {number} - The increment of the score.\n */\nfunction getScoreIncrement(numberOfBurnedLines, level) {\n  return SCORE_INCREMENTS[numberOfBurnedLines - 1] * (level + 1);\n}\n\n/**\n * Calculate the increment of the level. That increment equals 0 or 1 and it\n * depends on the level at the beginning of the game, the current level, the\n * total number of the burned lines, the current number of the burned lines.\n *\n * @param startLevel - The level at the beginning of the game.\n * @param level - The current level.\n * @param lines - The total number of the burned lines.\n * @param increment - The current number of the burned lines.\n * @returns {number} - The increment of the current level.\n */\nfunction getLevelIncrement(startLevel, level, lines, increment) {\n  if (startLevel === level) {\n    const bound1 = 10 * (startLevel + 1);\n    const bound2 = Math.max(100, startLevel * 10 - 50);\n    return lines + increment >= Math.min(bound1, bound2) ? 1 : 0;\n  }\n  const newLines = (lines + increment) % 10;\n  lines = lines % 10;\n  return lines > newLines ? 1 : 0;\n}\n\n/**\n * Calculate new delay of frames.\n *\n * @param level - The current level in the game.\n * @returns {number} - The frame delay.\n */\nfunction getDelayFrames(level) {\n  if (level >= 0 && level <= 8) {\n    return 48 - 5 * level;\n  }\n  if (level === 9) {\n    return 6;\n  }\n  if (level >= 10 && level <= 12) {\n    return 5;\n  }\n  if (level >= 13 && level <= 15) {\n    return 4;\n  }\n  if (level >= 16 && level <= 18) {\n    return 3;\n  }\n  if (level > 19 && level <= 28) {\n    return 2;\n  }\n  return 1;\n}\n\nmodule.exports = { show, getScoreIncrement, getLevelIncrement, getDelayFrames };\n\n\n//# sourceURL=webpack:///./src/modules/parameters.js?");

/***/ }),

/***/ "./src/modules/preview-canvas.js":
/*!***************************************!*\
  !*** ./src/modules/preview-canvas.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  LINE_PIXELS_IN_SQUARE,\n  GAME_BOARD_COLOR,\n  TETROMINOS\n} = __webpack_require__(/*! ./constants */ \"./src/modules/constants.js\");\nconst { paintSquare } = __webpack_require__(/*! ./square */ \"./src/modules/square.js\");\n\nconst canvas = document.getElementById('preview-canvas');\nconst cols = 5 * LINE_PIXELS_IN_SQUARE;\nconst rows = 4 * LINE_PIXELS_IN_SQUARE;\ncanvas.width = cols;\ncanvas.height = rows;\n\nconst context = canvas.getContext('2d');\n\ncanvas.style.backgroundColor = GAME_BOARD_COLOR;\n\nfunction renderTetromino(tetromino) {\n  const type = tetromino.type;\n  let squares;\n  let shiftX = 0;\n  let shiftY = 0;\n  switch (type) {\n    case TETROMINOS.I:\n      squares = [\n        { x: 0, y: 1 },\n        { x: 1, y: 1 },\n        { x: 2, y: 1 },\n        { x: 3, y: 1 }\n      ];\n      shiftX = LINE_PIXELS_IN_SQUARE / 2;\n      shiftY = shiftX;\n      break;\n    case TETROMINOS.L:\n      squares = [\n        { x: 1, y: 2 },\n        { x: 1, y: 1 },\n        { x: 2, y: 1 },\n        { x: 3, y: 1 }\n      ];\n      break;\n    case TETROMINOS.T:\n      squares = [\n        { x: 1, y: 1 },\n        { x: 2, y: 1 },\n        { x: 3, y: 1 },\n        { x: 2, y: 2 }\n      ];\n      break;\n    case TETROMINOS.J:\n      squares = [\n        { x: 1, y: 1 },\n        { x: 2, y: 1 },\n        { x: 3, y: 1 },\n        { x: 3, y: 2 }\n      ];\n      break;\n    case TETROMINOS.O:\n      squares = [\n        { x: 1, y: 1 },\n        { x: 1, y: 2 },\n        { x: 2, y: 1 },\n        { x: 2, y: 2 }\n      ];\n      shiftX = LINE_PIXELS_IN_SQUARE / 2;\n      shiftY = 0;\n      break;\n    case TETROMINOS.S:\n      squares = [\n        { x: 1, y: 1 },\n        { x: 2, y: 1 },\n        { x: 2, y: 2 },\n        { x: 3, y: 2 }\n      ];\n      break;\n    case TETROMINOS.Z:\n      squares = [\n        { x: 1, y: 2 },\n        { x: 2, y: 2 },\n        { x: 2, y: 1 },\n        { x: 3, y: 1 }\n      ];\n      break;\n    default:\n      squares = null;\n  }\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  squares.forEach(square =>\n    paintSquare(\n      square.x,\n      square.y,\n      tetromino.innerColor,\n      tetromino.borderColors,\n      drawPixel,\n      paintRect,\n      { x: shiftX, y: shiftY }\n    )\n  );\n}\n\nfunction drawPixel(x, y, color) {\n  context.fillStyle = color;\n  context.fillRect(x, y, 1, 1);\n}\n\nfunction paintRect(x1, y1, x2, y2, color) {\n  context.fillStyle = color;\n  context.fillRect(x1, y1, Math.abs(x2 - x1 + 1), Math.abs(y2 - y1 + 1));\n}\n\nfunction clearCanvas() {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nmodule.exports = { renderTetromino, clearCanvas };\n\n\n//# sourceURL=webpack:///./src/modules/preview-canvas.js?");

/***/ }),

/***/ "./src/modules/square.js":
/*!*******************************!*\
  !*** ./src/modules/square.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const constants = __webpack_require__(/*! ./constants */ \"./src/modules/constants.js\");\nconst canvas = __webpack_require__(/*! ./canvas */ \"./src/modules/canvas.js\");\n\nfunction isOnGameBoard(x, y) {\n  const isByX = x >= 0 && x < constants.SIZE_FIELD.WIDTH;\n  const isByY = y >= 0 && y < constants.SIZE_FIELD.HEIGHT;\n  return isByX && isByY;\n}\n\n/**\n * Get color of square on the game board.\n *\n * @param x - The first coordinate of the square on the game board.\n * @param y - The second coordinate of the square on the game board.\n * @returns {*}\n */\nfunction getColorOfSquare(x, y) {\n  const X = x * constants.LINE_PIXELS_IN_SQUARE;\n  const Y = y * constants.LINE_PIXELS_IN_SQUARE;\n  const color = canvas.getColorOfPixel(X, Y);\n  const colors = [constants.RED, constants.BLUE, constants.PURPLE];\n  return colors.reduce((acc, colorOfSquare) => {\n    if (colorOfSquare.innerColor === color) {\n      return colorOfSquare;\n    }\n    return acc;\n  }, undefined);\n}\n\n/**\n * We paint square of a game zone, which is a piece of a tetromino.\n *\n * @param {Number} x - The first coordinate of the square on the game field. We have\n * the following restriction: 0 <= x <= constants.SIZE_FIELD.WIDTH.\n * @param {Number} y - The second coordinate of the square on the game field. Feasible\n * values of the variable y are defined as follows: 0 <= y <= constants.SIZE_FIELD.HEIGHT.\n * @param {String} innerColor - The main color for the body of a square in the hex code\n * @param {String[]} borderColors - The border colors for the body of a square in the hex code\n * @param {Function} drawPixel - The function for pixel drawing on a canvas\n * @param {Function} paintRect\n * @param shift\n */\nfunction paintSquare(\n  x,\n  y,\n  innerColor,\n  borderColors,\n  drawPixel = canvas.drawPixel,\n  paintRect = canvas.paintRect,\n  shift = { x: 0, y: 0 }\n) {\n  const borderSize = borderColors.length;\n\n  /*\n   * Draw the border of the square. The border is multilayer.\n   * Outer layer has a level 0.\n   */\n  for (let layer = 0; layer < borderSize; layer++) {\n    let X = x * constants.LINE_PIXELS_IN_SQUARE + layer + shift.x;\n    let Y = y * constants.LINE_PIXELS_IN_SQUARE + layer + shift.y;\n    const color = borderColors[layer];\n    const size = constants.LINE_PIXELS_IN_SQUARE - 2 * layer;\n    for (let i = 0; i <= 2 * size - 1; i++) {\n      drawPixel(X, Y, color);\n      if (X < (x + 1) * constants.LINE_PIXELS_IN_SQUARE - layer - 1 + shift.x) {\n        drawPixel(X, Y + size - 1, color);\n        X++;\n      } else {\n        drawPixel(X - size + 1, Y, color);\n        Y++;\n      }\n    }\n  }\n  const x1 = x * constants.LINE_PIXELS_IN_SQUARE + borderSize + shift.x;\n  const y1 = y * constants.LINE_PIXELS_IN_SQUARE + borderSize + shift.y;\n  const eps = constants.LINE_PIXELS_IN_SQUARE - 2 * borderSize - 1;\n  paintRect(x1, y1, x1 + eps, y1 + eps, innerColor);\n}\n\n/**\n * Erase a square on the game board with the specified board coordinates\n * @param x - The first board coordinate of the erased square.\n * @param y - The second board coordinate of the erased square.\n */\nfunction eraseSquare(x, y) {\n  paintSquare(x, y, constants.GAME_BOARD_COLOR, []);\n}\n\nmodule.exports = { paintSquare, eraseSquare, getColorOfSquare, isOnGameBoard };\n\n\n//# sourceURL=webpack:///./src/modules/square.js?");

/***/ }),

/***/ "./src/modules/tetromino.js":
/*!**********************************!*\
  !*** ./src/modules/tetromino.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  isSquareFree,\n  eraseTetromino,\n  takeSquare,\n  drawTetromino\n} = __webpack_require__(/*! ./game-board */ \"./src/modules/game-board.js\");\nconst constants = __webpack_require__(/*! ./constants */ \"./src/modules/constants.js\");\nconst { isOnGameBoard } = __webpack_require__(/*! ./square */ \"./src/modules/square.js\");\n\n/**\n * Constructor for the tetromino object.\n *\n * @param type - The type of tetromino (a number from 0 to 6).\n * @param borderColors - The array of colors for the border of tetromino squares\n * @param innerColor - The color for inner area of tetromino squares.\n * @param squares - The array of objects with two properties --- coordinates of\n * tetromino squares.\n * @param reset - The function, which transform <squares> in the initial state.\n * @constructor\n */\nfunction Tetromino(type, borderColors, innerColor, squares, reset) {\n  this.type = type;\n  this.innerColor = innerColor;\n  this.borderColors = borderColors;\n  this.squares = squares;\n  this.reset = reset;\n}\n\n/**\n * Move the current tetromino to new position.\n *\n * @param sq - New coordinates for squares of the tetromino.\n * @returns {boolean}\n */\nTetromino.prototype.move = function move(sq) {\n  if (sq.every(s => isOnGameBoard(s.x, s.y) && isSquareFree(s.x, s.y))) {\n    eraseTetromino(this.squares);\n    this.squares = sq;\n    this.draw();\n    return true;\n  }\n  return false;\n};\n\n/**\n * Put squares of the tetromino on the bitmap of the game board.\n */\nTetromino.prototype.saveState = function saveState() {\n  this.squares.forEach(square => takeSquare(square.x, square.y));\n};\n\n/**\n * Render tetromino on the game board.\n */\nTetromino.prototype.draw = function draw() {\n  drawTetromino(this.squares, this.innerColor, this.borderColors, false);\n};\n\n/**\n * Move the tetromino left.\n *\n * @returns {boolean} - True, if we could move the tetromino; false, otherwise.\n */\nTetromino.prototype.moveLeft = function moveLeft() {\n  const updatedSquares = this.squares.map(square => ({\n    x: square.x - 1,\n    y: square.y\n  }));\n  return this.move(updatedSquares);\n};\n\n/**\n * Move the tetromino right.\n *\n * @returns {boolean} - True, if we could move the tetromino; false, otherwise.\n */\nTetromino.prototype.moveRight = function moveRight() {\n  const updatedSquares = this.squares.map(square => ({\n    x: square.x + 1,\n    y: square.y\n  }));\n  return this.move(updatedSquares);\n};\n\n/**\n * Rotate a square `S` with the board coordinates (x1, y1) around a position\n * with the board coordinates (x0, y0) by 90 deg. If `clockwise` = true, then\n * the rotation is clockwise, otherwise counterclockwise. Calculate new board\n * coordinates as follows: (x, y)' = (x0, y0)' + A * (x1 - x0, y1 - y0)',\n * where ' is the transpose of vectors and A is the transformation matrix\n * modelling the rotation\n * | 0        alpha |\n * | -alpha     0   |,\n * where alpha is 1 or -1.\n *\n * @param {number} x0 - The first coordinate of the rotation center\n * @param {number} y0 - The second coordinate of the rotation center\n * @param {number} x1 - The first coordinate of the rotated square\n * @param {number} y1 - The second coordinate of the rotated square\n * @param {boolean} clockwise - If true, then the rotation is clockwise,\n * otherwise counterclockwise\n *\n * @returns {*} - The board coordinates of new position for the square `S`.\n */\nfunction rotateSquare(x0, y0, x1, y1, clockwise) {\n  const alpha = clockwise ? -1 : 1;\n  const x = x0 + alpha * (y1 - y0);\n  const y = y0 - alpha * (x1 - x0);\n  return { x, y };\n}\n\n/**\n * Rotate the tetormino.\n *\n * @param clockwise - True, if ratation is in clockwise direction; false, otherwise.\n * @returns {Tetromino} - The tetromino.\n */\nTetromino.prototype.rotate = function rotate(clockwise) {\n  if (this.type !== constants.TETROMINOS.O) {\n    const rotatedTetromino = this.squares.map(square => {\n      const center =\n        this.type === constants.TETROMINOS.I\n          ? this.squares[2]\n          : this.squares[1];\n      return rotateSquare(center.x, center.y, square.x, square.y, clockwise);\n    });\n    this.move(rotatedTetromino);\n  }\n  return this;\n};\n\nconst I = new Tetromino(\n  constants.TETROMINOS.I,\n  constants.BLUE.borderColors,\n  constants.BLUE.innerColor,\n  [\n    { x: 3, y: 0 },\n    { x: 4, y: 0 },\n    { x: 5, y: 0 },\n    { x: 6, y: 0 }\n  ],\n  function reset() {\n    for (let i = 0; i < 4; i++) {\n      this.squares[i] = { x: 3 + i, y: 0 };\n    }\n  }\n);\n\nconst J = new Tetromino(\n  constants.TETROMINOS.J,\n  constants.RED.borderColors,\n  constants.RED.innerColor,\n  [\n    { x: 4, y: 0 },\n    { x: 5, y: 0 },\n    { x: 6, y: 0 },\n    { x: 6, y: 1 }\n  ],\n  function reset() {\n    this.squares = [\n      { x: 4, y: 0 },\n      { x: 5, y: 0 },\n      { x: 6, y: 0 },\n      { x: 6, y: 1 }\n    ];\n  }\n);\n\nconst L = new Tetromino(\n  constants.TETROMINOS.L,\n  constants.PURPLE.borderColors,\n  constants.PURPLE.innerColor,\n  [\n    { x: 4, y: 0 },\n    { x: 5, y: 0 },\n    { x: 6, y: 0 },\n    { x: 4, y: 1 }\n  ],\n  function reset() {\n    this.squares = [\n      { x: 4, y: 0 },\n      { x: 5, y: 0 },\n      { x: 6, y: 0 },\n      { x: 4, y: 1 }\n    ];\n  }\n);\n\nconst O = new Tetromino(\n  constants.TETROMINOS.O,\n  constants.BLUE.borderColors,\n  constants.BLUE.innerColor,\n  [\n    { x: 4, y: 0 },\n    { x: 5, y: 0 },\n    { x: 4, y: 1 },\n    { x: 5, y: 1 }\n  ],\n  function reset() {\n    for (let i = 0; i < 2; i++) {\n      this.squares[i] = { x: 4 + i, y: 0 };\n      this.squares[i + 2] = { x: 4 + i, y: 1 };\n    }\n  }\n);\n\nconst S = new Tetromino(\n  constants.TETROMINOS.S,\n  constants.PURPLE.borderColors,\n  constants.PURPLE.innerColor,\n  [\n    { x: 4, y: 0 },\n    { x: 5, y: 0 },\n    { x: 5, y: 1 },\n    { x: 6, y: 1 }\n  ],\n  function reset() {\n    for (let i = 1; i <= 2; i++) {\n      this.squares[i - 1] = { x: 3 + i, y: 0 };\n      this.squares[i + 1] = { x: 4 + i, y: 1 };\n    }\n  }\n);\n\nconst T = new Tetromino(\n  constants.TETROMINOS.T,\n  constants.BLUE.borderColors,\n  constants.BLUE.innerColor,\n  [\n    { x: 4, y: 0 },\n    { x: 5, y: 0 },\n    { x: 6, y: 0 },\n    { x: 5, y: 1 }\n  ],\n  function reset() {\n    this.squares = [\n      { x: 4, y: 0 },\n      { x: 5, y: 0 },\n      { x: 6, y: 0 },\n      { x: 5, y: 1 }\n    ];\n  }\n);\n\nconst Z = new Tetromino(\n  constants.TETROMINOS.Z,\n  constants.RED.borderColors,\n  constants.RED.innerColor,\n  [\n    { x: 4, y: 1 },\n    { x: 5, y: 1 },\n    { x: 5, y: 0 },\n    { x: 6, y: 0 }\n  ],\n  function reset() {\n    for (let i = 1; i <= 2; i++) {\n      this.squares[i - 1] = { x: 3 + i, y: 1 };\n      this.squares[i + 1] = { x: 4 + i, y: 0 };\n    }\n  }\n);\n\nmodule.exports = { tetrominos: [I, J, L, O, S, T, Z] };\n\n\n//# sourceURL=webpack:///./src/modules/tetromino.js?");

/***/ })

/******/ });